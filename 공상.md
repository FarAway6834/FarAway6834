# 서론

𝔹 = {T, F}인 불 연산과 동등한 체계의 예시로, Zhegalkin Polynomial 이 있다.

모듈라 2 환에서의 Zhegalkin Polynomial을
우리가 쓰는 GF(2)에서 유도하는 LAFTF를
알아보자.

먼저 형변환 술어 bool로 수를 bool로 바꿀수 있다.
bool : {0, 1} x -> (x = 1) (= (x ≠ 0))
사실은, int := bool⁻¹ 에서,
int(p) = 1 if p else 0으로, 조각적 정의가 가능하여,
두 방법으로 다 유도가 되지만 말이다.

이렇게 정의된 int와 bool로 논리연산을 대수연산으로 평가할수 있다.

---

# 본론

## 최소한의 NOT & AND 논리가 유도되는지 보자.
### 논리곱과 곱의 비교를 동해 int(bool(p) ∧ bool(q)) = pq임을 입증하자.

1. 영권과 일원에 대해, 멱원과 항등원이다.
2. 다르거나 같은 p, q에 대해, 교환법칙이 성립한다.
3. 따라서 그 그래프와 정의역이 동등함. (사실 계산식 4개만 쓰면 이게 바로나온다)

### int(¬bool(p)) = 1 - p임을 입증해보자.

-p는 0, -1을 뱉는다. 정의역에서 벗어난다.
p - 1 (이전수 연산)은 -1, 0을 뱉는다. 정의역에서 벗어난다.
1 - p가 된다.
#### 유도된 식을 증명해보자.
미분같은거 쓸필요 없이, 직선의 방정식에서 (0, 1)과 (1, 0)을 지나는 직선의 방정식은 y = 1 - x다.
Q.E.D.

## XOR과 OR

### 논리합
덧셈에 (0, 0) ~ (1, 1)까지 배정해주면, (0, 1, 1, 2)
곱셈에 (0, 0) ~ (1, 1)까지 배정해주면, (0, 0, 0, 1)
빼주면, 논리합인 (0, 1, 1, 1)이며,
이는 드모르간의 법칙으로 유도해도 맞다.

### 베타적 논리합

논리합과 같은방법으로 x + y - 2xy가 배타적 논리합임을 알수 있다.

그러나, 베타적 논리합은 Zhegalkin 다항식(Polynomial)에서는, 이를 구현할 방법이 없어, ⊕를 가진다.

x ↔ y = x → y ∧ y → x의 부정으로써
x ⊕ y = (x ∧ ¬y) ∨ (¬x ∧ y)
 = (x - y) ∨ (y - x)
 = (x ∨ y) - (x ∧ y) (단. x - y := ¬ (x → y) = x ∧ ¬ y)

인데 (지금 본인이 이차식이 싫기때문에 이차식으로 전개해야하는 (x ∨ y) - (x ∧ y)는 전개하지 않겠음, 선형적인게 최고인 법이지 << 퍽퍽)

x(1 - y) + y(1 - x) + xy(1-x)(1-y)에서,
x(1 - y) + y(1 - x) = x - xy + y - xy이고,
xy(1 - x)(1 - y)에서나오는 p(1 - p)가 만족불가능이기 때문에, xy(1 - x)(1 - y) = 0이다.

## 비트연산

솔찍히 말하자면 나는 이 연산에 대해 아직 잘 모르겠다.
d진수 n 비트 비트 연산은, 모듈라 dⁿ을 확장한것으로 생각해도 될것같다. n = 1인 특수한 경우를 논리연산으로 보고, 여러개인 경우를 비트연산으로 보는것이다 (백터화 연산)

하지만 Σ f(x[n], y[n]) 2ⁿ (n = 1 ~ maxbit)에서 f가 덧셈을 보존해주지 않을거기 때문에,

보수연산 (혹은 정통 laftf명칭으로 bitwise nagator) (2ⁿ - 1) - x을 제외한 다른 연산은 나는 할엄두를 내지 못하였었다.

### 비트를 인덱싱하는 비트인덱서 (비트 인덱싱 함수)

idx(n', x, n) = shl(bit)ⁿ • shrⁿ'(x)
와 같이 정의된다.

### shift right function

shr(x) = (x - (x mod2))/2 = ⌊x/2⌋
와 같이 심플하고 귀엽게 식이 나온다.

### bitwise functions

(bitwise • f)(bit, x1, ..., xn) := Σ f(idx(bit, x1, n), ..., idx(bit, xn, n)) 2ⁿ (n = 0 ~ bit)

이렇게 예쁘게 식이 나온다.

### 지시함수를 유도해보도록 해보자.

서로 역함수인
Set(p) = {x | p(x)}, Boolf(S)(x) = (x ∈ S)
을 Set과 Bool사이의 변환으로 보자고 하자.
이전에 말했었던거 말이다.

intf := (int •) •Boolf와 setized := Set • (bool •)를 만들어봤을때, 집합은 대수 함수로 재밌게 바꿔볼수 있다.

이잔에 말했었던 조건부 정의 (조각적 정의)를 논리곱을 여러개 쓴 연립식으로 둔 정의에서,

intf(S)(x) = 1 if x ∈ S else 0 이다.
이는 지시함수랑 동등하다.

### 조건문 함수

dose(p, x) := (1 • Set • bool(p))(x) (단. 1은 지시함수)에서,

dose(p, x) := x if p else 0가 된다.

단순히 python수준의 단순한 코딩보다도 쉬우니 넘어가고,

유사 구간 역미분이라는 전에 언급한 체계에서 다뤗듯,

cond(p, x, y)를 p가 1일때와 p가 0일때에 대해, 조각적으로 정의될떼 이것이, 지시함수로 표현가능함으로,

cond(p, x, y) = dose(p, x) + dose(1 - p, y) = px + (1 - p)y = p(x - y) + y

예쁘게 완성된다.

---

# 결론

LAFTF는 제귀를 나타낼수 없어, 튜링완전하지 않다.

LAFTF는 반드시 유한시간내에 결정된다.

수열식으로써 정의할때 제귀를 이용할수 있다.

LAFTF와 수열의 제귀적 정의를 이용하여, 수열로 튜링머신을 만들수 있다.

여기서 모든 수를 선형대수적으로 치환하면 어떨까...

아름다울것같다.

사실 전혀 모르겠다.

슬프게도, 수식만으론 프로그래밍 가능하진 않고, 단순히 패턴으로 이해할수 있는 Sequence 함수, 수열을 어색하게 붙여야했다.